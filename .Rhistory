'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3)
)
)
}
# print(lagDay)
cat(
paste(lagDay,'Avg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
,'\n','-----','\n ',
'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3)
)
)
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
,'\n','-----','\n ',
'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3)
)
)
for( lagDay in 1:12){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
,'-----',
'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3)
)
)
}
for( lagDay in 1:12){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3),
'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3),
'\n-----\n',
)
)
}
for( lagDay in 1:12){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3),
'Avg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3),
'\n-----\n'
)
)
}
for( lagDay in 1:12){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3),
'\nAvg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3),
'\n-----\n'
)
)
}
diffLagLbsRev(1)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
diffLagLbsRev(2)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
diffLagLbsRev(3)[[1]] %>%
mean(na.rm = TRUE) %>% round(3)
diffLagLbsRev(3)[[1]]
for( lagDay in 1:15){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3),
'\nAvg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3),
'\n-----\n'
)
)
}
for( lagDay in 1:30){
# print(lagDay)
cat(
paste(lagDay, '\nAvg Difference of Sales',
diffLagLbsRev(lagDay)[[1]] %>%
mean(na.rm = TRUE) %>% round(3),
'\nAvg Difference of Revenue', diffLagLbsRev(lagDay)[[2]] %>%
mean(na.rm = TRUE) %>% round(3),
'\n-----\n'
)
)
}
visitsFinancials %>% colnames()
lm(Lbs._Sold ~ . , data = visitsFinancials)
visitsFinancials %>% colnames()
lm(Lbs._Sold ~ Visits + Unique_Visits , data = visitsFinancials)
lm(Lbs._Sold ~ . , data = visitsFinancials) %>% summary()
visitsFinancials %>% colnames()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + Pages/Visits, data = visitsFinancials)
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + Pages/Visit, data = visitsFinancials)
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$Pages/Visit, data = visitsFinancials)
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit`, data = visitsFinancials)
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews ,
data = visitsFinancials)
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews ,
data = visitsFinancials) %>% summary()
data = visitsFinancials) %>% summary()
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$Pageviews
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$Pageviews,
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit`,
data = visitsFinancials) %>% summary()
visitsFinancials %>% colnames()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
Avg._Time_on_Site_(secs.),
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
visitsFinancials$`Avg._Time_on_Site_(secs.)`,
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
visitsFinancials$`Avg._Time_on_Site_(secs.)` + Bounce_Rate,
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
visitsFinancials$`Avg._Time_on_Site_(secs.)` + Bounce_Rate + %_New_Visits,
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
visitsFinancials$`Avg._Time_on_Site_(secs.)` + Bounce_Rate + visitsFinancials$`%_New_Visits`,
data = visitsFinancials) %>% summary()
visitsFinancials %>% colnames()
lm(Lbs._Sold ~ Visits + Unique_Visits + Pageviews + visitsFinancials$`Pages/Visit` +
visitsFinancials$`Avg._Time_on_Site_(secs.)` + Bounce_Rate + visitsFinancials$`%_New_Visits`+
Inquiries,
data = visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Visits + Bounce_Rate) %>% summary()
lm(Lbs._Sold ~ Visits + Bounce_Rate, visitsFinancials) %>% summary()
lm(Lbs._Sold ~ Bounce_Rate, visitsFinancials) %>% summary()
lm(Revenue ~ Pageviews, visitsFinancials) %>% summary()
lm(Profit ~ Pageviews, visitsFinancials) %>% summary()
lm(Revenue ~ Visits + visitsFinancials$Pageviews + visitsFinancials$`Avg. Time on Site (secs.)` +
visitsFinancials$`Bounce Rate` + visitsFinancials$`% New Visits` + visitsFinancials$Inquiries, visitsFinancials) %>% summary()
lm(Revenue ~ Visits + visitsFinancials$Pageviews + visitsFinancials$`Avg. Time on Site (secs.)` +
visitsFinancials$`Bounce Rate` + visitsFinancials$`% New Visits` + visitsFinancials$Inquiries, visitsFinancials) %>% summary()
lm(Revenue ~ Visits + visitsFinancials$Pageviews + visitsFinancials$`Avg._Time_on_Site_(secs.)` +
visitsFinancials$`Bounce_Rate` + visitsFinancials$`%_New_Visits` + visitsFinancials$Inquiries, visitsFinancials) %>% summary()
lm(Profit ~ Pageviews, visitsFinancials) %>% summary()
lm(Revenue ~ Pageviews, visitsFinancials) %>% summary()
visitsFinancials %>% ggplot(aes(x = campaign,y = Profit)) +
geom_bar(stat = 'summary',fun.y = 'mean') +
scale_x_discrete(labels = c('Initial','Pre-promotion','Promotion', 'Post-promotion'))
visitsFinancials %>% ggplot(aes(x = campaign,y = Profit)) +
geom_bar(stat = 'summary',fun.y = 'mean') +
scale_x_discrete(labels = c('Initial','Pre-promotion','Promotion', 'Post-promotion'))
visitsFinancials %>% ggplot(aes(x = campaign,y = Profit)) +
geom_bar(stat = 'summary',fun.y = 'mean')
visitsFinancials %>% ggplot(aes(x = factor(campaign),y = Profit)) +
geom_bar(stat = 'summary',fun.y = 'mean') +
scale_x_discrete(labels = c('Initial','Pre-promotion','Promotion', 'Post-promotion'))
# Homework 3 --------------------------------------------------------------
library(magrittr)
# Chapter 3.4: Exercises: 7 and 8
'
7.Create	 a	 user	 defined	 function	 named	 studentfunction that
transposes	a	numeric matrix (columns	become	rows)	and	subsets
the	matrix in	a	way	 so	that	only	the	first	5	 rows	 remain	in	the
dataset.
a) Use	 the	 studentfunction function	 to	 transform	 the	 matrix
created	in	Exercise	7	from	chapter	2.
b) Use	the studentfunction function	to	transform	the	matrix	that
was	given	as	an	example	in	chapter	2.1
'
studentFunction <- function(Matrix){
# transposes	a	numeric matrix (columns	become	rows)
transposedMatrix <- t(Matrix)
# subsets the	matrix in	a	way	 so	that	only	the	first	5	 rows	 remain	in	the dataset
return(transposedMatrix[1:5,])
}
matrixGeneration <- function(StringVector,numberOfColumns){
# The string vector must be separated by a single space
# and must be numeric.
# e.g. '1 2 3'
# The function fills by column. Thus, numberOfColumns of desired matrix
# must be indicated
matrixVector <- strsplit(StringVector, ' ') %>%
unlist() %>%
as.vector() %>%
as.numeric()
return(matrix(matrixVector,byrow = TRUE,
ncol = numberOfColumns))
}
# 1.a
stringMat1 <-'10 11 9 15 19 52 19 7 10 22 28 40 6 99 33 35 26 5 87 91 0 12 16 81 200'
matEx1 <- matrixGeneration(stringMat1,5)
studentFunction(ex7Chap2Mat)
# 1.b
# Is not possible because the instructions for the function dictates that
# it is necessary to subset the first 5 rows.
# this is not possible for transposed matrices with less than 5 rows
stringMat2 <-'1 2 3 4 5 6 7 8 9'
matEx2<- matrixGeneration(stringMat2, 3)
studentFunction(stringMat2)
'
8.Create	 a	 user	 defined	 function	 named	 transformmatrix that
takes the	diagonal	of	a	matrix	and	calculates	a	vector	with	two
elements.	Element	one	is	the	mean	of	the	diagonal	and	element
two	is	the	median.
a)	 Use	 the	 transformmatrix function	 to	 transform	 the	 matrix
created	in	Exercise	7	from	chapter	2.
b)	Use	the transformmatrix	function	to	transform	the	matrix	that
was	given	as	an	example	in	chapter	2.1
'
transformMatrix <- function(Matrix){
# This function returns the diagonal's mean and median of a given Matrix
# The output is a list with two elements:
# meanOfMatrixDiagonal, medianOfMatrixDiagional
return(list(meanOfMatrixDiagonal = diag(Matrix) %>% mean(),
medianOfMatrixDiagonal = diag(Matrix) %>% median() ))
}
# a
transformMatrix(matEx1)
# b
transformMatrix(matEx2)
# Chapter 4.4: Exercise: 9
'9. For	the	iris	dataset	(no	need	to	call	a	function,	iris	is	part	of	the
base	 R) create	 for	 loop that	 does	 the	 following	 to	 each
observation:
a)	changes	the	Species	column	from	a	character	type	to	numeric.
Assign	1 for	setosa,	2	for	virginica,	and	3	for	versicolor,
b)	 creates	 a	 new	 column	 that	 groups	 the	 Petal.Length	 into	 3
groups:	group#1	for	Petal.Length	from	0	to	2,	group	#2	from	2.01
to	4.5,	and	group	#3	from	4.51	to	7.
'
data("iris")
#A
for( i in 1:nrow(iris)){
if (as.character(iris$Species[i]) == 'setosa'){
iris$SpeciesCoded[i] <- 1
} else if(as.character(iris$Species[i]) == 'virginica') {
iris$SpeciesCoded[i] <- 2
} else if(as.character(iris$Species[i]) == 'versicolor'){
iris$SpeciesCoded[i] <- 3
} else { next }
}
# B
for( i in 1:nrow(iris)){
if (iris$Petal.Length[i] >= 0 & iris$Petal.Length[i] <= 2){
iris$PetalGrouped[i] <- 'Group1'
} else if(iris$Petal.Length[i] >= 2.01 & iris$Petal.Length[i] <= 4.5){
iris$PetalGrouped[i] <- 'Group2'
} else if(iris$Petal.Length[i] >= 4.51 & iris$Petal.Length[i] <= 7){
iris$PetalGrouped[i] <- 'Group3'
} else{ next }
}
iris[,c('Petal.Length', 'PetalGrouped')]
#
# Chapter 6.7: Exercise: 3
'
3.Using	the	iris	dataset:
a)	combine	the	Setosa	and	Versicolor	into	group	“0”	and	label	the
Virginica	to	“1”.	Create	a	new	variable	called	iris$Group	with	the
0	or	1	labels,
b)	build	a	logistic	regression	model	using	any	available	data	that
will	predict	the	observation	being	Virginica	(	value of	1	in	Group
variable),
c)	calculate	the	probability	of	a	new	plant	being	a	Virginica	for	the
following	parameters:
Sepal.Width	=5
Petal.Length	=10
Petal.Width	=7
Sepal.Length=9
'
iris$Species
for(i in 1:nrows(iris)){
if(iris$Species[i] == 'setosa' | iris$Species[i] == 'versicolor'){
iris$Group[i] <- 0
} else {
iris$Group[i] <- 1
}
}
for(i in 1:Nrows(iris)){
if(iris$Species[i] == 'setosa' | iris$Species[i] == 'versicolor'){
iris$Group[i] <- 0
} else {
iris$Group[i] <- 1
}
}
for(i in 1:nrow(iris)){
if(iris$Species[i] == 'setosa' | iris$Species[i] == 'versicolor'){
iris$Group[i] <- 0
} else {
iris$Group[i] <- 1
}
}
iris
View(iris)
iris %>% colnames()
#b
irisLogistic <- glm(Group ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width)
#b
irisLogistic <- glm(Group ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
data = iris, family = 'binomial')
#b
irisLogistic <- glm(Group ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
data = iris, family = 'binomial')
irisLogistic
irisLogistic %>% summary()
prob <- function(inter,beta1,x){
logit <- inter + beta1*x
odds <- exp(logit)
prob <- odds/(1+odds)
return(c(odds,prob))
}
prob(irisLogistic$coefficients[1],irisLogistic$coefficients[2],30)
prob <- function(inter,beta1,x){
logit <- inter + beta1*x
odds <- exp(logit)
prob <- odds/(1+odds)
return(list(Odds = odds, Probability = prob))
}
prob(irisLogistic$coefficients[1],irisLogistic$coefficients[2],30)
irisLogistic$coefficients
irisLogistic$coefficients[1]
irisLogistic$coefficients[[1]]
prob(irisLogistic$coefficients[[1]],irisLogistic$coefficients[[2]],30)
predict(Sepal.Width	=5,
Petal.Length	=10,
Petal.Width	=7,
Sepal.Length=9,
data = iris,
type='response')
newDataIrisDf <- data.frame(Sepal.Width	=5,
Petal.Length	=10,
Petal.Width	=7,
Sepal.Length=9)
predict(newDataIrisDf,
data = iris,
type='response')
predict(irisLogistic,
newDataIrisDf,
type='response')
matrixGeneration <- function(StringVector,numberOfColumns){
# The string vector must be separated by a single space
# and must be numeric.
# e.g. '1 2 3'
# The function fills by column. Thus, numberOfColumns of desired matrix
# must be indicated
matrixVector <- strsplit(StringVector, ' ') %>%
unlist() %>%
as.vector() %>%
as.numeric()
return(matrix(matrixVector,byrow = TRUE,
ncol = numberOfColumns))
}
matrixGeneration <- function(StringVector,numberOfColumns){
# The string vector must be separated by a single space
# and must be numeric.
# e.g. '1 2 3'
# The function fills by column. Thus, numberOfColumns of desired matrix
# must be indicated
matrixVector <- strsplit(StringVector, ' ') %>%
unlist() %>%
as.vector() %>%
as.numeric()
return(matrix(matrixVector,byrow = TRUE,
ncol = numberOfColumns))
}
plot(cars)
# Raw string is defined
stringMat1 <-'10 11 9 15 19 52 19 7 10 22 28 40 6 99 33 35 26 5 87 91 0 12 16 81 200'
# The string is converted to the appropriate matrix
matEx1 <- matrixGeneration(stringMat1,5)
matEx1
studentFunction(ex7Chap2Mat)
# Raw string is defined
stringMat1 <-'10 11 9 15 19 52 19 7 10 22 28 40 6 99 33 35 26 5 87 91 0 12 16 81 200'
# The string is converted to the appropriate matrix
matEx1 <- matrixGeneration(stringMat1,5)
matEx1
studentFunction(ex7Chap2Mat)
studentFunction <- function(Matrix){
tryCatch({
# transposes	a	numeric matrix (columns	become	rows)
transposedMatrix <- t(Matrix)
# subsets the	matrix in	a	way	 so	that	only	the	first	5	 rows	 remain	in	the dataset
return(transposedMatrix[1:5,])
})
}
# Raw string is defined
stringMat1 <-'10 11 9 15 19 52 19 7 10 22 28 40 6 99 33 35 26 5 87 91 0 12 16 81 200'
# The string is converted to the appropriate matrix
matEx1 <- matrixGeneration(stringMat1,5)
matEx1
studentFunction(ex7Chap2Mat)
studentFunction(matEx1)
studentFunction(matEx1)
# The string is converted to the appropriate matrix
matEx1 <- matrixGeneration(stringMat1,5)
matEx1
studentFunction(matEx1)
studentFunction <- function(Matrix){
tryCatch(
expr = {
# transposes	a	numeric matrix (columns	become	rows)
transposedMatrix <- t(Matrix)
# subsets the	matrix in	a	way	 so	that	only	the	first	5	 rows	 remain	in	the                 dataset
return(transposedMatrix[1:5,])
}, error = function(e){
message('ERROR OCCURED, transposed matrix rows >= 5?')
print(e)
})
}
studentFunction(matEx1)
studentFunction(stringMat2)
stringMat2 <-'1 2 3 4 5 6 7 8 9'
matEx2<- matrixGeneration(stringMat2, 3)
studentFunction(stringMat2)
stringMat2 <-'1 2 3 4 5 6 7 8 9'
matEx2<- matrixGeneration(stringMat2, 3)
studentFunction(matEx2)
matEx2
studentFunction(matEx2)
stringMat2 <-'1 2 3 4 5 6 7 8 9'
matEx2<- matrixGeneration(stringMat2, 3)
matEx2
studentFunction(matEx2)
# Raw string is defined
stringMat2 <-'1 2 3 4 5 6 7 8 9'
# The istring is converted to the appropriate matrix
matEx2<- matrixGeneration(stringMat2, 3)
# Matrix is printed to console
print(matEx2)
# Student Function execution
studentFunction(matEx2)
transformMatrix <- function(Matrix){
# This function returns the diagonal's mean and median of a given Matrix
# The output is a list with two elements:
# meanOfMatrixDiagonal, medianOfMatrixDiagional
return(list(meanOfMatrixDiagonal = diag(Matrix) %>% mean(),
medianOfMatrixDiagonal = diag(Matrix) %>% median() ))
}
transformMatrix(matEx1)
transformMatrix(matEx2)
library(magrittr)
transformMatrix <- function(Matrix){
# This function returns the diagonal's mean and median of a given Matrix
# The output is a list with two elements:
# meanOfMatrixDiagonal, medianOfMatrixDiagional
return(list(meanOfMatrixDiagonal = diag(Matrix) %>% mean(),
medianOfMatrixDiagonal = diag(Matrix) %>% median() ))
}
transformMatrix(matEx2)
for( i in 1:nrow(iris)){
if (as.character(iris$Species[i]) == 'setosa'){
iris$Species[i] <- 1
} else if(as.character(iris$Species[i]) == 'virginica') {
iris$Species[i] <- 2
} else if(as.character(iris$Species[i]) == 'versicolor'){
iris$Species[i] <- 3
} else { next }
}
data("iris")
#A
for( i in 1:nrow(iris)){
if (as.character(iris$Species[i]) == 'setosa'){
iris$SpeciesCoded[i] <- 1
} else if(as.character(iris$Species[i]) == 'virginica') {
iris$SpeciesCoded[i] <- 2
} else if(as.character(iris$Species[i]) == 'versicolor'){
iris$SpeciesCoded[i] <- 3
} else { next }
}
# Making sure that iris is in the session
data("iris")
iris
# Creating new variable with a for loop
for( i in 1:nrow(iris)){
if (as.character(iris$Species[i]) == 'setosa'){
iris$SpeciesCoded[i] <- 1
} else if(as.character(iris$Species[i]) == 'virginica') {
iris$SpeciesCoded[i] <- 2
} else if(as.character(iris$Species[i]) == 'versicolor'){
iris$SpeciesCoded[i] <- 3
} else { next }
}
iris
iris[,c("Species","SpeciesCoded")]
for( i in 1:nrow(iris)){
if (iris$Petal.Length[i] >= 0 & iris$Petal.Length[i] <= 2){
iris$PetalGrouped[i] <- 'Group1'
} else if(iris$Petal.Length[i] >= 2.01 & iris$Petal.Length[i] <= 4.5){
iris$PetalGrouped[i] <- 'Group2'
} else if(iris$Petal.Length[i] >= 4.51 & iris$Petal.Length[i] <= 7){
iris$PetalGrouped[i] <- 'Group3'
} else{ next }
}
iris[,c('Petal.Length', 'PetalGrouped')]
tinytex::install_tinytex()
predict(irisLogistic,
newDataIrisDf)
